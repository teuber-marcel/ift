/**
 * @file
 * @brief Segments an image with Simple Prob. Atlas, and LogReg trained with supervoxels generated by SLIC.
 * The program segments an image using Prob. Atlas and a LogReg Classifier. \n
 * The LogReg is trained with supervoxels generated by SLIC using brightness values ([avg, stdev, min, max])
 * for each supervoxel. \n
 * The training supervoxel dataset is obtained by the program demo/Superpixels/iftDataSetsBySLIC.c.
 * @note See the source code in @ref iftSegmentImageBySLIC-LogReg.c
 *
 * @example iftSegmentImageBySLIC-LogReg.c
 * @brief Segments an image with Simple Prob. Atlas, and LogReg trained with supervoxels generated by SLIC.
 * The program segments an image using Prob. Atlas and a LogReg Classifier. \n
 * The LogReg is trained with supervoxels generated by SLIC using brightness values ([avg, stdev, min, max])
 * for each supervoxel. \n
 * The training supervoxel dataset is obtained by the program demo/Superpixels/iftDataSetsBySLIC.c.
 * @author Samuel Martins
 * @date Jun 28, 2016
 */


#include "ift.h"


/************************** HEADERS **************************/
iftDict *iftGetArgs(int argc, const char *argv[]);
void iftGetRequiredArgs(  iftDict *args, char **img_path, char **atlas_path, char **bright_data_path,
                        int *input_n_clusters, double *comp, char **out_img_path);
void iftValidateInputs(const char *img_path, const char *atlas_path, const char *bright_data_path,
                       int input_n_clusters, double comp, const char *out_img_path);
int iftGetImageMaxRange(  iftDict *args,   iftImage *img);
void iftPreProcessProbAtlas(iftProbAtlas *atlas);
void iftValidateTestImageAndProbAtlas(  iftImage *img,   iftSimpleProbAtlas *atlas);
iftLabeledSet *iftGenerateAtlasSeedsByLogReg(  iftImage *img,   iftImage *super_img, int img_max_range,
                                   const char *bright_data_path,   iftFImage *model,   iftImage *label_map);
iftImage *iftSegmentByWatershed(  iftImage *img, iftLabeledSet *seeds);
/*************************************************************/


int main(int argc, const char *argv[]) {
    iftDict *args = iftGetArgs(argc, argv);

    // mandatory args
    char *img_path         = NULL;
    char *atlas_path       = NULL;
    char *bright_data_path = NULL;
    int input_n_clusters;
    double comp;
    char *out_img_path;

    iftGetRequiredArgs(args, &img_path, &atlas_path, &bright_data_path, &input_n_clusters, &comp, &out_img_path);
    timer *t1 = iftTic();

    iftImage *img             = iftReadImageByExt(img_path);
    int img_max_range         = iftGetImageMaxRange(args, img);
    iftSimpleProbAtlas *atlas = iftReadSimpleProbAtlas(atlas_path);
    iftValidateTestImageAndProbAtlas(img, atlas);

    puts("- Generating Supervoxels by SLIC");
    t1 = iftTic();
    iftImage *super_img = iftGenerateSuperpixelsBySlic(img, NULL, input_n_clusters, comp, img_max_range, NULL);
    puts("Super");
    puts(iftFormattedTime(iftCompTime(t1, iftToc())));
    puts("");

    puts("- Generating Seeds by Atlas and Classifier");
    iftLabeledSet *seeds = iftGenerateAtlasSeedsByLogReg(img, super_img, img_max_range, bright_data_path,
                                                         atlas->model, atlas->label_map);
    iftDestroyImage(&super_img);
    iftDestroySimpleProbAtlas(&atlas);

    puts("- Segmenting Test Image by Watershed");
    iftImage *seg_img = iftSegmentByWatershed(img, seeds);
    iftWriteImageByExt(seg_img, out_img_path);
    iftDestroyImage(&seg_img);


    puts("\nDone...");
    puts(iftFormattedTime(iftCompTime(t1, iftToc())));


    // DESTROYERS
    iftDestroyDict(&args);
    iftDestroyImage(&img);
    iftFree(img_path);
    iftFree(atlas_path);
    iftFree(bright_data_path);
    iftFree(out_img_path);
    iftDestroyLabeledSet(&seeds);

    return 0;
}



/************************** SOURCES **************************/
iftDict *iftGetArgs(int argc, const char *argv[]) {
    char program_description[2048] = \
        "The program segments an image using Simple Prob. Atlas and a LogReg Classifier.\n" \
        "The LogReg is trained with supervoxels generated by SLIC using brightness values ([avg, stdev, min, max]) " \
        "for each supervoxel.\n" \
        "The training supervoxel dataset is obtained by the program demo/Superpixels/iftDataSetsBySLIC.c.";

    iftCmdLineOpt cmd_line_opts[] = {
        {.short_name = "-i", .long_name = "--input-test-img", .has_arg=true, .arg_type=IFT_STR_TYPE,
         .required=true, .help="Image to be segmented."},
        {.short_name = "-p", .long_name = "--simple-prob-atlas", .has_arg=true, .arg_type=IFT_STR_TYPE,
         .required=true, .help="Simple Probabilist Atlas used for delineation (*.zip)."},
        {.short_name = "-d", .long_name = "--train-brightness-dataset", .has_arg=true, .arg_type=IFT_STR_TYPE,
         .required=true, .help="Pathname from the Dataset of Brightness (*.zip)."},
        {.short_name = "-k", .long_name = "--num-clusters", .has_arg=true, .arg_type=IFT_LONG_TYPE,
         .required=true, .help="Approximate Number of Superpixels."},
        {.short_name = "-c", .long_name = "--compactness", .has_arg=true, .arg_type=IFT_DBL_TYPE,
         .required=true, .help="Compactness: Relative Importance of color similarity and spatial proximity.\n" \
                                "Try values on a log scale (0.01, 0.1, 1, 10, 100) before refining " \
                                "around a chosen value."},
        {.short_name = "-o", .long_name = "--output-img", .has_arg=true, .arg_type=IFT_STR_TYPE,
         .required=true, .help="Pathname from the Output Segmented Image."},
        {.short_name = "-j", .long_name = "--img-depth", .has_arg=true, .arg_type=IFT_LONG_TYPE,
         .required=false, .help="Input Image Depth in bits (8, 12, 16, ...)\n" \
                                "Default: it tries to find the image depth automatically from the First Image"},
        {.short_name = "", .long_name = "--num-threads", .has_arg=true, .arg_type=IFT_LONG_TYPE,
         .required=false, .help="Number of Threads of the program.\nDefault: use all threads possible."}
    };
    int n_opts = sizeof(cmd_line_opts) / sizeof (iftCmdLineOpt);

    // Parser Setup
    iftCmdLineParser *parser = iftCreateCmdLineParser(program_description, n_opts, cmd_line_opts);
    iftDict *args            = iftParseCmdLine(argc, argv, parser); // getting the passed options/arguments
    iftDestroyCmdLineParser(&parser);

    return args;
}


void iftGetRequiredArgs(  iftDict *args, char **img_path, char **atlas_path, char **bright_data_path,
                        int *input_n_clusters, double *comp, char **out_img_path) {
    *img_path         = iftGetStrValFromDict("--input-test-img", args);
    *atlas_path       = iftGetStrValFromDict("--simple-prob-atlas", args);
    *bright_data_path = iftGetStrValFromDict("--train-brightness-dataset", args);
    *input_n_clusters = iftGetLongValFromDict("--num-clusters", args);
    *comp             = iftGetDblValFromDict("--compactness", args);
    *out_img_path     = iftGetStrValFromDict("--output-img", args);

    iftValidateInputs(*img_path, *atlas_path, *bright_data_path, *input_n_clusters, *comp, *out_img_path);

    puts("-----------------------");
    printf("- Input Image: \"%s\"\n", *img_path);
    printf("- Prob Atlas: \"%s\"\n", *atlas_path);
    printf("- Brightness Dataset: \"%s\"\n", *bright_data_path);
    printf("- Input Desired Number of Superpixels/Supervoxels: %d\n", *input_n_clusters);
    printf("- Compactness: %lf\n", *comp);
    printf("- Output Image Pathname: \"%s\"\n", *out_img_path);
    puts("-----------------------");
}


void iftValidateInputs(const char *img_path, const char *atlas_path, const char *bright_data_path,
                       int input_n_clusters, double comp, const char *out_img_path) {
    // input image
    if (!iftIsImageFile(img_path))
        iftError("The input image \"%s\" is not a valid image (*.[pgm,ppm,png,scn]) or it does not exist",
                 "iftValidateInputs", img_path);

    // prob atlas
    if (!iftFileExists(atlas_path))
        iftError("Prob. Atlas does not exist: \"%s\"", "iftValidateInputs", atlas_path);

    // bright. dataset
    if (!iftFileExists(bright_data_path))
        iftError("Brightness Dataset does not exist: \"%s\"", "iftValidateInputs", bright_data_path);

    // num of clusters
    if (input_n_clusters <= 0)
        iftError("Invalid Desired Number of Superpixels: %ld... Try > 0", "iftValidateInputs", input_n_clusters);

    // compactness
    if (comp <= 0.0)
        iftError("Invalid Compactness: %lf... Try > 0 (0.01, 0.1, 1, 10)", "iftValidateInputs", comp);

    // output image
    if (!iftIsImagePathnameValid(out_img_path))
        iftError("Invalid Output Image Pathname: \"%s\"", "iftValidateInputs", out_img_path);

    char *parent_dir = iftParentDir(out_img_path);
    if (!iftDirExists(parent_dir)) {
        iftMakeDir(parent_dir);
    }
    iftFree(parent_dir);
}


int iftGetImageMaxRange(  iftDict *args,   iftImage *img) {
    int img_max_range;

    if (iftDictContainKey("--img-depth", args, NULL)) {
        int img_depth = iftGetLongValFromDict("--img-depth", args);
        if (img_depth <= 0)
            iftError("Invalid Image Depth: %d... Try > 0", "iftGetOptionalArgs", img_depth);

        img_max_range = (1 << img_depth) - 1; // (2^img_depth) - 1
    }
    else img_max_range = iftNormalizationValue(iftMaximumValue(img));

    printf("- Image Range: [0, %d]\n", img_max_range);
    puts("-----------------------\n");

    return img_max_range;
}


// Destroys the seeds, regions of uncertainty, pdfs, and msps search region
void iftPreProcessProbAtlas(iftProbAtlas *atlas) {
    iftProbAtlas *aux = (iftProbAtlas*) iftAlloc(1, sizeof(iftProbAtlas));

    aux->n_objs = atlas->n_objs;

    aux->seeds   = atlas->seeds;
    atlas->seeds = NULL;

    aux->unc_regions   = atlas->unc_regions;
    atlas->unc_regions = NULL;
    
    aux->pdf   = atlas->pdf;
    atlas->pdf = NULL;

    aux->search_regions   = atlas->search_regions;
    atlas->search_regions = NULL;

    iftDestroyProbAtlas(&aux);
}


void iftValidateTestImageAndProbAtlas(  iftImage *img,   iftSimpleProbAtlas *atlas) {
    if (!iftIsDomainEqual(img, atlas->model))
        iftError("Test Image and Prob Atlas have different Domains\n" \
                 "Test (xsize, ysize, zsize): %d, %d, %d\n" \
                 "Prob. Atlas (xsize, ysize, zsize): %d, %d, %d", "iftValidateTestImageAndProbAtlas",
                 img->xsize, img->ysize, img->zsize, atlas->model->xsize, atlas->model->ysize, atlas->model->zsize);
    if (!iftIsVoxelSizeEqual(img, atlas->model))
        iftError("Test Image and Prob Atlas have different Voxel Sizes\n" \
                 "Test (%lf, %lf, %lf)\n" \
                 "Prob. Atlas (%lf, %lf, %lf)", "iftValidateTestImageAndProbAtlas", 
                 img->dx, img->dy, img->dz, atlas->model->dx, atlas->model->dy, atlas->model->dz);
}


iftLabeledSet *iftGenerateAtlasSeedsByLogReg(  iftImage *img,   iftImage *super_img, int img_max_range,
                                   const char *bright_data_path,   iftFImage *model,   iftImage *label_map) {
    iftDataSet *Ztrain = iftReadOPFDataSet(bright_data_path);
    printf("- Ztrain: nsamples: %d, nfeats: %d, nclasses: %d\n", Ztrain->nsamples, Ztrain->nfeats, Ztrain->nclasses);
    iftSetStatus(Ztrain, IFT_TRAIN);

    iftDataSet *Ztest = iftSupervoxelsToGrayAvgStdevMinMaxDataSet(img, super_img, img_max_range, false, NULL);
    Ztest->nclasses   = Ztrain->nclasses; // required for the LogClassify
    printf("- Ztest: nsamples: %d, nfeats: %d\n", Ztest->nsamples, Ztest->nfeats);

    puts("- Training LogReg");
    iftLogReg *logreg = iftLogRegTrain(Ztrain);
    timer *t1 = iftTic();
    iftLogRegClassify(logreg, Ztest);
    puts("Time Classification");
    puts(iftFormattedTime(iftCompTime(t1, iftToc())));
    puts("");
    iftDestroyLogReg(&logreg);

    // seeds for the WaterShed algorithm
    iftLabeledSet *seeds = NULL;

    // geodesic centers from the supervoxels
    iftLabeledSet *centers = iftGeodesicCenters(super_img);
    while (centers != NULL) {
        int super_label; // supervoxel label
        int p = iftRemoveLabeledSet(&centers, &super_label);
        int c = super_label - 1;     // ex: supervoxel's label 2 has index [1] 


        // if its an object according to the prob. atlas
        if (iftAlmostZero(model->val[p] - 1.0)) {
            // if its background according to the texture
            if (Ztest->sample[c].label == 1) {
                iftInsertLabeledSet(&seeds, p, 0); // marks as bg
            }
            // if its an object according to the texture
            else if (Ztest->sample[c].label == 2) {
                iftInsertLabeledSet(&seeds, p, label_map->val[p]); // marks as object
            }
        }
        else if (iftAlmostZero(model->val[p])) {
            // if its background according to the texture
            if (Ztest->sample[c].label == 1) {
                iftInsertLabeledSet(&seeds, p, 0); // marks as bg
            }
        }
    }

//    iftImage *out = iftCreateImage(img->xsize, img->ysize, img->zsize);
//    while (seeds != NULL) {
//        int label;
//        int p = iftRemoveLabeledSet(&seeds, &label);
//        out->val[p] = label+1;
//    }
//    iftWriteImage(out, "vis/seeds.scn");

    iftDestroyDataSet(&Ztrain);
    iftDestroyDataSet(&Ztest);
    iftDestroyLabeledSet(&centers);

    return seeds;
}


iftImage *iftSegmentByWatershed(  iftImage *img, iftLabeledSet *seeds) {
    iftAdjRel *A = NULL;
    iftAdjRel *B = NULL;
    if (iftIs3DImage(img)) {
        A = iftSpheric(1.74); // sqrt(3.0)
        B = iftSpheric(1.0);
    }
    else {
        A = iftCircular(1.42); // sqrt(2.0)
        B = iftCircular(1.0);
    }

//    iftImage *grad_img = iftImageBasins(img, A);
    iftImage *grad_img = iftBrainGrad(img);
    iftWriteImage(grad_img, "vis/grad.scn");
    iftImage *seg_img  = iftWatershed(grad_img, B, seeds, NULL);


    iftDestroyImage(&grad_img);
    iftDestroyAdjRel(&A);
    iftDestroyAdjRel(&B);

    return seg_img;
}







