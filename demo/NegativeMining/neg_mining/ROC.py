"""
Plot ROC curves
"""
# Author: Samuel Martins <sbm.martins@gmail.com>
# License: Unicamp
# Date: April, 9, 2015

# See an example of json plot config in "neg_mining/plot/plot.json"
# IT WORKS FOR MATPLOTLIB >= 1.4.3

import json
import math
import numpy as np
import os
import random
from scipy import stats
from scipy import interpolate
from scipy.optimize import curve_fit
from sklearn.metrics import roc_curve
import sys
import pdb

import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
from pylab import setp


def print_error(msg, function):      
    sys.exit("\n*** PYTHON: ERROR in \"{0}\":\n{1}\n\n".format(function, msg))


def generate_uniform_markers(far, xticks, xscale, n_marks_per_tick_interval):
    """Generate markers according to a uniform distribution over the xticks.

    Parameters
    ----------
    xticks: list
        List of ticks from the x axis which will be used to generate the markers
        in an uniform distribution.

    xscale: string
        Scale of the x axis.

    n_marks_per_tick_interval: int
        Tick frequency from the uniform distribution.

    Returns
    -------
    mark_idxs: list
        Ticks generated by an uniform distribution.
    """
    mark_idxs = []
    tick_prev = xticks[0]

    for tick in xticks[1:]:
        if xscale == "log":
            uniform_dist = np.logspace(math.log10(tick_prev), math.log10(tick), 
                                       n_marks_per_tick_interval,
                                       endpoint=True)
        else:
            uniform_dist = np.linspace(tick_prev, tick, 
                                       n_marks_per_tick_interval,
                                       endpoint=True)

        for x in uniform_dist:
            mark_idxs.append((np.abs(far-x)).argmin())
        tick_prev = tick

    return mark_idxs



def average_car(far, ROC_functions):
    """Compute the Average CAR values for a given FAR set.

    Parameters
    ----------
    far: numpy.array of shape (n_splits, n_far_values)
        Numpy array with FAR values.

    ROC_functions: list of interp1d functions with shape (n_splits).
        List with pre-computed ROC functions, so that each one corresponds to a ROC function
        from a iteration.

    Returns
    -------
    avg_car: numpy.array
        Numpy array with the average of CAR values obtained by the ROC functions.
    """
    ret      = 0.
    n_splits = len(ROC_functions)

    for s, ROC_f in enumerate(ROC_functions):
        ret += ROC_functions[s](far)

    return np.array(ret / n_splits)



def standard_error_car(far, avg_car, ROC_functions):
    """Compute the Standard Error CAR values.

    Parameters
    ----------
    far: numpy.array of shape (n_splits, n_far_values)
        Numpy array with FAR values.

    avg_car: numpy.array of shape (n_splits, n_car_values)
        Numpy array with the average CAR values obtained with far and ROC_functions
        in the function "average_car".

    ROC_functions: list of interp1d functions with shape (n_splits).
        List with pre-computed ROC functions, so that each one corresponds to a ROC function
        from a iteration.

    Returns
    -------
    avg_car: numpy.array
        Numpy array with the average of CAR values obtained by the ROC functions.
    """
    ret      = 0.
    n_splits = len(ROC_functions)

    for s, ROC_f in enumerate(ROC_functions):
        ret += pow(avg_car - ROC_functions[s](far), 2)

    stderr_car = np.sqrt(ret / (n_splits - 1.)) / np.sqrt(n_splits)

    return stderr_car




def plot_one(neg, pos, plot_dict, xticks=None, xscale=None):
    """Plot the interpolation of the negative and positive scores.
    Assume that both lists of pos and neg files are organized in the same order
    of iterations. E.g: pos_files[0] = "pos_it01.npy", neg_files[0] = "neg_it01.npy"


    Parameters
    ----------
    neg: matrix of floats with shape (n_iters, n_neg_samples)
        Matrix of the scores from the Negative Samples.
        Each row corresponds to a list of Negative sample scores of a iteration.

    pos: matrix of floats with shape (n_iters, n_pos_samples)
        Matrix of the scores from the Positive Samples.
        Each row corresponds to a list of Positive sample scores of a iteration.

    plot_dict: dict
        Configs of the curve.
        See the Json file explanation at the end from the file for more informations.

    xticks: list
        List of ticks from the x axis.
        It is just used if the ticks distribution is uniform, i.e.
        plot_dict["markevery"] == "uniform".

    xscale: string
        Scale from the x axis.
        It is just used if the ticks distribution is uniform, i.e.
        plot_dict["markevery"] == "uniform".
    """
    all_far       = []
    ROC_functions       = []
    splits        = range(len(neg))

    for s in splits:
        # -- prepare data
        labels      = np.array([-1]*len(neg[s]) + [1]*len(pos[s]))
        scores      = np.append(neg[s], pos[s])
        
        # Computes the FAR and CAR values
        far, car, _ = roc_curve(labels, scores, pos_label=1)
        far         = far * 100
        car         = car * 100

        # Generate a ROC function that maps f(far_value) = car_value
        # This is useful to be able to compute more points on the curve, avoiding
        # automatic generation by the plt.plot()
        # Thus, the curve will be smoothed.
        ROC_f = interpolate.interp1d(far, car, kind='linear')
        # IMPORTANT: Trick to avoid gaps in the curve. E.g: Car values not defined to far_value = 0.01.
        # Changes all elements = 0 to 1e-8
        far[far==0] = 1e-8

        all_far.append(far)
        ROC_functions.append(ROC_f)


    # generates an uniform distribution of marks on the curve
    if plot_dict.get("markevery", None) == "uniform":
        n_marks_per_tick_interval = plot_dict.get("n_marks_per_tick_interval", 3)
        plot_dict["markevery"] = generate_uniform_markers(all_far[0], xticks, xscale, n_marks_per_tick_interval)

        if "n_marks_per_tick_interval" in plot_dict.keys():
            # this key does not exist in plt.plot(..., **plot_dict)
            del plot_dict["n_marks_per_tick_interval"]

    # Build a dict of configs about the Standard Error Roc Curve
    plot_sem_dict = dict(plot_dict)
    plot_sem_dict.pop("marker", None)
    plot_sem_dict.pop("markersize", None)
    plot_sem_dict.pop("markerevery", None)
    plot_sem_dict.pop("label", None)
    plot_sem_dict["linestyle"] = "dotted"

    # We've just figured out all ROC functions based on the values from FARs and CARs.
    # Now, for a given FAR set, we'll compute the average CAR values,
    # obtained by the ROC functions.
    avg_car    = average_car(all_far[0], ROC_functions)

    # Plot the curves
    plt.plot(all_far[0], avg_car, **plot_dict)
    
    if len(splits) >= 2:
        # After that, we'll compute the standard error for the same FAR points.
        stderr_car = standard_error_car(all_far[0], avg_car, ROC_functions)
        plt.plot(all_far[0], avg_car+stderr_car, **plot_sem_dict)
        plt.plot(all_far[0], avg_car-stderr_car, **plot_sem_dict)


    # return the index of the sample with nearest <far> from 0.01
    # This "trick" is needed because we can have <far> very close to 0.01,
    # but with car_function very different. Thus, the curve won't match with the ytick
    # in far = 0.01 (x axis) 
    idx_close_0_01        = (np.abs(all_far[0]-0.01)).argmin()
    car_at_far_close_0_01 = average_car(all_far[0][idx_close_0_01], ROC_functions)

    if len(splits) >= 2:
        print("- far_close_0_01  = (%.4f), car_at_far_close_0_01 = %.2f +- %.2f" % (all_far[0][idx_close_0_01], car_at_far_close_0_01, stderr_car[idx_close_0_01]))
    else:
        print("- far_close_0_01  = (%.4f), car_at_far_close_0_01 = %.2f" % (all_far[0][idx_close_0_01], car_at_far_close_0_01))
    print("- car_0_01 = %.2f\n" % average_car(0.01, ROC_functions))

    return car_at_far_close_0_01






def plot_roc(plot):
    """Plots ROC graphs from a json config file. 
    Each ROC graph must be specified in the key "ROC_GRAPHS" in the json file.
    Its curves are specified inside it.


    Notes
    -----
    The specification of all parameters from plot (json file) is showed in the end of this file.
    See an example of json plot config in "neg_mining/plot/plot.json"
    """
    roc_graphs = plot["ROC_GRAPHS"]
    graph_keys = sorted(roc_graphs.keys())

    for key in graph_keys:
    # for graph_name, graph in roc_graphs.items():
        graph_name = key
        graph      = roc_graphs[key]
        
        if graph["active"]:
            ############### Setting the General configs from the Graph ############## 
            plt.figure(**graph["figure"])
            plt.title(graph["title"]["label"], **graph["title"]["fontdict"])
            plt.grid(graph["grid"])

            plt.xlabel(graph["xlabel"]["label"], **graph["xlabel"]["fontdict"])
            plt.xlim(**graph["xlim"])
            plt.xscale(graph["xscale"])

            if graph["xticks"].get("ticks"):
                plt.xticks(graph["xticks"]["ticks"], graph["xticks"]["labels"], **graph["xticks"]["fontdict"])
            else:
                plt.xticks(np.linspace(graph["xlim"]["xmin"], graph["xlim"]["xmax"], graph["xticks"]["n_ticks"], 
                           endpoint=graph["xticks"]["endpoint"]), **graph["xticks"]["fontdict"])

            plt.ylabel(graph["ylabel"]["label"], **graph["ylabel"]["fontdict"])
            plt.ylim(**graph["ylim"])
            plt.yscale(graph["yscale"])

            if graph["yticks"].get("ticks"):
                plt.yticks(graph["yticks"]["ticks"], graph["yticks"]["labels"], **graph["yticks"]["fontdict"])
            else:
                plt.yticks(np.linspace(graph["ylim"]["ymin"], graph["ylim"]["ymax"], graph["yticks"]["n_ticks"], endpoint=graph["yticks"]["endpoint"]), **graph["yticks"]["fontdict"])
            ######################################################################### 


            curve_keys = sorted(graph["curves"].keys())

            print("##### %s #####" % graph["title"]["label"])
            for key2 in curve_keys:
                curve = graph["curves"][key2]
                print("--> %s" % key2)
                
                if curve["active"]:
                    pos, neg = [], []

                    # Assume that both lists of pos and neg files are organized in the same order
                    # of iterations. E.g: pos_files[0] = "pos_it01.npy", neg_files[0] = "neg_it01.npy"
                    # POSITIVES - one file (score list) per split
                    for pos_file in curve["pos_files"]:
                        pos.append(np.load(os.path.expanduser(pos_file)))
                    # NEGATIVES - one file (score list) per split
                    for neg_file in curve["neg_files"]:
                        neg.append(np.load(os.path.expanduser(neg_file)))

                    if len(pos) != len(neg):
                        print_error("Number of positive files != Number of negative files: %d, %d - %s - %s" 
                            % (len(pos), len(neg), graph_name, key2), "plot_roc")


                    car_0_01 = plot_one(neg, pos, curve["plot"], plt.xticks()[0], graph["xscale"])

            legend = plt.legend(loc=graph["legend"]["loc"], title=graph["legend"]["title"])
            setp(legend.get_title(), fontsize=graph["legend"]["title_fontsize"], family=graph["legend"]["family"])
            setp(legend.get_texts(), fontsize=graph["legend"]["text_fontsize"], family=graph["legend"]["family"])

            print("- Saving plot in \"%s\"\n" % graph["savefig"]["fname"])

            if graph["savefig"]["format"].upper() == "PDF":
                pp = PdfPages(graph["savefig"]["fname"])
                plt.savefig(pp, **graph["savefig"])
                pp.close()
            else:
                plt.savefig(graph["savefig"]["fname"], **graph["savefig"])

            plt.cla()
            plt.clf()
            plt.close()





def main():
    if (len(sys.argv) == 1):
        print_error("plot_graph.py <plot_config1.json> <plot_config2.json> ...", "main")
    
    for i in range(1, len(sys.argv)):
        json_file = open(sys.argv[i])
    
        try:
            plot_config = json.load(json_file)
            #         print(json.dumps(configs, sort_keys=True, indent=4))
        except (ValueError, KeyError, TypeError):
            print_error("JSON format error", "main")

        plot_roc(plot_config)

if __name__ == "__main__":    
    sys.exit(main())



"""
Json configs.


Parameters
----------
plot: dict of ROC Graphs configs.
    ROC_GRAPHS: dict of configs
        Contains the configs from the ROC graphs to be plotted.
        Each one of its keys correspond to a dict of configs about a ROC curve.

        ROC_CURVE_key: dict. It can be almost name.
            Dict of configs from the ROC curve "ROC_CURVE_key".

            active: boolean
                If true, the script will plot the graph.

            figure: dict
                Configs about the plot image resolutions.

                figsize: list of float
                    Resolution from the plot image.
                    E.g: [10, 5]

            title: dict 
                Dict with the configs from the Plot Title.
                
                label: string
                    Plot name.
                
                fontdict: dict
                    Dict with the configs about the font.
                    
                    fontsize: int

                    weight: string
                        Options = ['light', 'normal', 'medium', 'semibold', 'bold', 'heavy', 'black']

                    family: string
                        Font-family
            
            grid: boolean
                Show or not the grid on the plot.

            xlabel: dict
                Configs about the x axis on the plot.

                label: string
                    Name of the x axis.

                fontdict: dict
                    Dict with the configs about the font.
                    See the [title] dict to more informations.

            xlim: dict
                Configs about the limits of the x axis.

                xmin: int

                xmax: int

            xscale: string
                Scale of the x axis.
                Options = ['linear', 'log' ].
                Log corresponds to the log10 scale.

            xticks: dict
                Configs about the ticks from the x axis.

                ticks: list (optional)
                    List with points on the x axis which will have ticks.
                    This list must have the size from the config n_ticks.
                    We can omit this keys.
                    If it doesn't exist, the script will assign ticks automatically.

                labels: list
                    List with the labels from the ticks.
                    This list must have the size from the config n_ticks.
                    It is also used if the key ticks exists.

                n_ticks: int
                    Number of ticks.

                endpoint: boolean
                    Put tick or not on the end point of the x axis.

                fontdict: dict
                    Dict with the configs about the font.
                    See the [title] dict to more informations.

            ylabel: dict
                Configs about the y axis on the plot.

                label: string
                    Name of the y axis.

                fontdict: dict
                    Dict with the configs about the font.
                    See the [title] dict to more informations.

            ylim: dict
                Configs about the limits of the y axis.

                ymin: int

                ymax: int

            yscale: string
                Scale of the y axis.
                Options = ['linear', 'log' ].
                Log corresponds to the log10 scale.

            yticks: dict
                Configs about the ticks from the y axis.

                ticks: list
                    List with points on the y axis which will have ticks.
                    This list must have the size from the config n_ticks.
                    We can omit this keys.
                    If it doesn't exist, the script will assign ticks automatically.

                labels: list
                    List with the labels from the ticks.
                    This list must have the size from the config n_ticks.
                    It is also used if the key ticks exists.


                n_ticks: int
                    Number of ticks.

                endpoint: boolean
                    Put tick or not on the end point of the y axis.

                fontdict: dict
                    Dict with the configs about the font.
                    See the [title] dict to more informations.

            legend: dict
                Configs about the legend of the plot.

                loc: string
                    Legend location.
                    Options: http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.legend

                title: string
                    Legend title.

                title_fontsize: int
                    Font size of the legend title.

                text_fontsize: int
                    Font size of the legend content.

                family: string
                    Legend font family.

            savefig: dict
                Configs about the plot saving.

                fname: string
                    Filename of the plot.

                dpi: int
                    Resolution of the plot.

                format: string
                    Format of the plot file.
                    Options: ["pdf", "png", ...]


            curves: dict
                Dict with the configs of each curve from the plot.
                Each curve dict is a key.

                curve_key_name: config dict of a curve. It can be almost name.
                    active: boolean
                        If active, plot the curve.

                    plot: dict
                        Configs of the curve.

                        label: string
                            Name of the plot.

                        color: string
                            Color of the curve in HTML format.

                        linewidth: float

                        linestyle: string
                            Options: ['-', '--', '-.', ':', 'None', ' ', '']

                        marker: string
                            Marker of the curve.
                            Oprtions: http://matplotlib.org/api/markers_api.html#module-matplotlib.markers

                        markersize: float
                            Size of the marker.

                        markevery: int, float or string
                            Put on marker every .. points.
                            http://matplotlib.org/api/lines_api.html#matplotlib.lines.Line2D.set_markersize

                            Custom value: "uniform"
                                Distribute the marker on the curve uniformly.
                                The number of markers is given by n_marks_per_tick_interval.

                            
                        n_marks_per_tick_interval: int
                            Number of ticks used in the marker uniform distribution.
                            It is also used if markevery = "uniform".

                    pos_files: list of string
                        List with pathnames of the positive sample scores.
                        The files must be .npy
                        
                    neg_files: list of string
                        List with pathnames of the negative sample scores.
                        The files must be .npy




                    legend: string
                        Curve legend.

                    pos_files: list of string
                        List of filenames of the positive scores. Each name corresponds to a binary file with scores to be plotted.

                    neg_files: list of string
                        List of filenames of the negative scores. Each name corresponds to a binary file with scores to be plotted.

"""